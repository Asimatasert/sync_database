#!/bin/bash

# sync_database - Remote PostgreSQL database dump and sync script
# Usage: bash sync_database --database dbname --username user --password pass --exclude table1,table2

set -e

# Get the directory where this script is located
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"

# Default values
DATABASE="your_database_name"
EXCLUDE_TABLES=""
EXCLUDE_SCHEMAS=""
AUTO_RESTORE=false
KEEP_DUMPS=0  # 0 means keep all dumps

# Compression settings
COMPRESSION_ENABLED=true
COMPRESSION_TYPE="gzip"  # gzip, xz, bzip2, none
COMPRESSION_LEVEL=6      # 1-9 (1=fast, 9=best compression)
PG_DUMP_COMPRESSION=6    # pg_dump internal compression (0-9, for custom format)

# Source database configuration (where to dump from)
SOURCE_DB_HOST="localhost"
SOURCE_DB_PORT="5432"
SOURCE_DB_USER="postgres"
SOURCE_DB_PASSWORD=""

# Destination database configuration (where to restore to)
DEST_DB_NAME=""
DEST_DB_HOST="localhost"
DEST_DB_PORT="5432"
DEST_DB_USER="postgres"
DEST_DB_PASSWORD=""

# Remote server configuration (SSH RSA key configured)
REMOTE_USER="your_ssh_user"
REMOTE_HOST=""
REMOTE_PORT="22"
REMOTE_DUMP_DIR="/tmp"

# Local configuration
LOCAL_DUMP_DIR="${SCRIPT_DIR}/data/dumps"
TIMESTAMP=$(date +%Y%m%d_%H%M%S)

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
NC='\033[0m' # No Color

# Parse command line arguments
while [[ $# -gt 0 ]]; do
    case $1 in
        --database)
            DATABASE="$2"
            shift 2
            ;;
        --exclude)
            EXCLUDE_TABLES="$2"
            shift 2
            ;;
        --exclude-schema)
            EXCLUDE_SCHEMAS="$2"
            shift 2
            ;;
        --remote-user)
            REMOTE_USER="$2"
            shift 2
            ;;
        --remote-ip)
            REMOTE_HOST="$2"
            shift 2
            ;;
        --remote-port)
            REMOTE_PORT="$2"
            shift 2
            ;;
        --source-host)
            SOURCE_DB_HOST="$2"
            shift 2
            ;;
        --source-port)
            SOURCE_DB_PORT="$2"
            shift 2
            ;;
        --source-user)
            SOURCE_DB_USER="$2"
            shift 2
            ;;
        --source-password)
            SOURCE_DB_PASSWORD="$2"
            shift 2
            ;;
        --restore)
            AUTO_RESTORE=true
            shift 1
            ;;
        --dest-database)
            DEST_DB_NAME="$2"
            shift 2
            ;;
        --dest-host)
            DEST_DB_HOST="$2"
            shift 2
            ;;
        --dest-port)
            DEST_DB_PORT="$2"
            shift 2
            ;;
        --dest-user)
            DEST_DB_USER="$2"
            shift 2
            ;;
        --dest-password)
            DEST_DB_PASSWORD="$2"
            shift 2
            ;;
        --compression)
            COMPRESSION_TYPE="$2"
            if [ "$COMPRESSION_TYPE" = "none" ]; then
                COMPRESSION_ENABLED=false
            fi
            shift 2
            ;;
        --compression-level)
            COMPRESSION_LEVEL="$2"
            shift 2
            ;;
        --pg-compression)
            PG_DUMP_COMPRESSION="$2"
            shift 2
            ;;
        --keep-dumps)
            KEEP_DUMPS="$2"
            shift 2
            ;;
        --help)
            echo "Usage: bash sync_database [OPTIONS]"
            echo ""
            echo "Options:"
            echo "  --database NAME            Source database name (default: your_database_name)"
            echo "  --exclude TABLES           Comma-separated list of tables to exclude"
            echo "  --exclude-schema SCHEMAS   Comma-separated list of schemas to exclude"
            echo ""
            echo "Remote Server Options (SSH connection):"
            echo "  --remote-user USER         SSH username (default: your_ssh_user)"
            echo "  --remote-ip IP             SSH server IP (required)"
            echo "  --remote-port PORT         SSH port (default: 22)"
            echo ""
            echo "Source Database Options (where to dump from):"
            echo "  --source-host HOST         Source DB host on remote server (default: localhost)"
            echo "  --source-port PORT         Source DB port (default: 5432)"
            echo "  --source-user USER         Source DB username (default: postgres)"
            echo "  --source-password PASS     Source DB password (required)"
            echo ""
            echo "Destination Database Options (where to restore to):"
            echo "  --restore                  Automatically restore after sync"
            echo "  --dest-database NAME       Destination DB name (default: same as source)"
            echo "  --dest-host HOST           Destination DB host (default: localhost)"
            echo "  --dest-port PORT           Destination DB port (default: 5432)"
            echo "  --dest-user USER           Destination DB username (default: postgres)"
            echo "  --dest-password PASS       Destination DB password (required for restore)"
            echo ""
            echo "Compression Options:"
            echo "  --compression TYPE         Compression type: gzip, xz, bzip2, none (default: gzip)"
            echo "  --compression-level LEVEL  Compression level 1-9 (default: 6)"
            echo "  --pg-compression LEVEL     PostgreSQL dump compression 0-9 (default: 6)"
            echo ""
            echo "Dump Management:"
            echo "  --keep-dumps N             Keep only last N dumps, delete older ones (default: 0, keep all)"
            echo ""
            echo "  --help                     Show this help message"
            echo ""
            echo "Examples:"
            echo "  # Dump only from remote server"
            echo "  bash sync_database --database mydb --source-password secret --remote-ip 192.168.1.100"
            echo ""
            echo "  # Dump from remote DB on different host and restore locally"
            echo "  bash sync_database --database mydb \\"
            echo "    --source-password secret --source-host 10.0.0.5 \\"
            echo "    --remote-ip 192.168.1.100 \\"
            echo "    --restore --dest-password localpass"
            echo ""
            echo "  # Restore to different database name"
            echo "  bash sync_database --database proddb \\"
            echo "    --source-password secret --remote-ip 192.168.1.100 \\"
            echo "    --restore --dest-database devdb --dest-password localpass"
            echo ""
            echo "  # With exclude tables"
            echo "  bash sync_database --database mydb \\"
            echo "    --source-password secret --remote-ip 192.168.1.100 \\"
            echo "    --exclude logs,sessions --restore --dest-password localpass"
            exit 0
            ;;
        *)
            echo -e "${RED}Error: Unknown option: $1${NC}"
            echo "Use --help for usage information"
            exit 1
            ;;
    esac
done

# Validate required parameters
if [ -z "$SOURCE_DB_PASSWORD" ]; then
    echo -e "${RED}Error: --source-password is required${NC}"
    exit 1
fi

if [ -z "$REMOTE_HOST" ]; then
    echo -e "${RED}Error: --remote-ip is required${NC}"
    exit 1
fi

if [ "$AUTO_RESTORE" = true ] && [ -z "$DEST_DB_PASSWORD" ]; then
    echo -e "${RED}Error: --dest-password is required when using --restore${NC}"
    exit 1
fi

# Set destination database name to source if not specified
if [ -z "$DEST_DB_NAME" ]; then
    DEST_DB_NAME="$DATABASE"
fi

# Create local dump directory if it doesn't exist
mkdir -p "$LOCAL_DUMP_DIR"

# Generate dump filename
DUMP_FILENAME="${DATABASE}_${TIMESTAMP}.dump"
REMOTE_DUMP_PATH="${REMOTE_DUMP_DIR}/${DUMP_FILENAME}"
LOCAL_DUMP_PATH="${LOCAL_DUMP_DIR}/${DUMP_FILENAME}"

# Compression file extensions
case "$COMPRESSION_TYPE" in
    gzip)
        COMPRESSION_EXT=".gz"
        COMPRESS_CMD="gzip -${COMPRESSION_LEVEL}"
        DECOMPRESS_CMD="gunzip"
        ;;
    xz)
        COMPRESSION_EXT=".xz"
        COMPRESS_CMD="xz -${COMPRESSION_LEVEL}"
        DECOMPRESS_CMD="unxz"
        ;;
    bzip2)
        COMPRESSION_EXT=".bz2"
        COMPRESS_CMD="bzip2 -${COMPRESSION_LEVEL}"
        DECOMPRESS_CMD="bunzip2"
        ;;
    none)
        COMPRESSION_EXT=""
        COMPRESS_CMD=""
        DECOMPRESS_CMD=""
        COMPRESSION_ENABLED=false
        ;;
    *)
        echo -e "${RED}Error: Invalid compression type: $COMPRESSION_TYPE${NC}"
        echo "Valid types: gzip, xz, bzip2, none"
        exit 1
        ;;
esac

echo -e "${GREEN}=== Database Sync Started ===${NC}"
echo "Source Database: $DATABASE"
echo "Source DB: ${SOURCE_DB_HOST}:${SOURCE_DB_PORT} (user: ${SOURCE_DB_USER})"
echo "Remote SSH: ${REMOTE_USER}@${REMOTE_HOST}:${REMOTE_PORT}"
if [ "$AUTO_RESTORE" = true ]; then
    echo "Destination Database: $DEST_DB_NAME"
    echo "Destination DB: ${DEST_DB_HOST}:${DEST_DB_PORT} (user: ${DEST_DB_USER})"
fi
if [ -n "$EXCLUDE_TABLES" ]; then
    echo "Excluding tables: $EXCLUDE_TABLES"
fi
if [ -n "$EXCLUDE_SCHEMAS" ]; then
    echo "Excluding schemas: $EXCLUDE_SCHEMAS"
fi
if [ "$COMPRESSION_ENABLED" = true ]; then
    echo "Compression: ${COMPRESSION_TYPE} (level: ${COMPRESSION_LEVEL}, pg_dump: ${PG_DUMP_COMPRESSION})"
else
    echo "Compression: disabled"
fi
echo ""

# Build pg_dump command with exclude options
# -Fc: Custom format
# -Z: Compression level for custom format
# -v: Verbose
PG_DUMP_CMD="PGPASSWORD='$SOURCE_DB_PASSWORD' pg_dump -U $SOURCE_DB_USER -h $SOURCE_DB_HOST -p $SOURCE_DB_PORT -Fc -Z${PG_DUMP_COMPRESSION} -v -f $REMOTE_DUMP_PATH $DATABASE"

# Add exclude-table options
if [ -n "$EXCLUDE_TABLES" ]; then
    IFS=',' read -ra TABLES <<< "$EXCLUDE_TABLES"
    for table in "${TABLES[@]}"; do
        # Trim whitespace
        table=$(echo "$table" | xargs)
        PG_DUMP_CMD="$PG_DUMP_CMD --exclude-table='$table'"
    done
fi

# Add exclude-schema options
if [ -n "$EXCLUDE_SCHEMAS" ]; then
    IFS=',' read -ra SCHEMAS <<< "$EXCLUDE_SCHEMAS"
    for schema in "${SCHEMAS[@]}"; do
        # Trim whitespace
        schema=$(echo "$schema" | xargs)
        PG_DUMP_CMD="$PG_DUMP_CMD --exclude-schema='$schema'"
    done
fi

echo -e "${YELLOW}Step 1/5: Creating database dump on remote server...${NC}"
ssh -p ${REMOTE_PORT} ${REMOTE_USER}@${REMOTE_HOST} "$PG_DUMP_CMD"

if [ $? -eq 0 ]; then
    echo -e "${GREEN}✓ Database dump created successfully${NC}"
else
    echo -e "${RED}✗ Failed to create database dump${NC}"
    exit 1
fi

echo ""
echo -e "${YELLOW}Step 2/5: Checking dump file size...${NC}"
REMOTE_SIZE=$(ssh -p ${REMOTE_PORT} ${REMOTE_USER}@${REMOTE_HOST} "ls -lh $REMOTE_DUMP_PATH | awk '{print \$5}'")
REMOTE_SIZE_BYTES=$(ssh -p ${REMOTE_PORT} ${REMOTE_USER}@${REMOTE_HOST} "stat -f%z $REMOTE_DUMP_PATH 2>/dev/null || stat -c%s $REMOTE_DUMP_PATH 2>/dev/null")
echo -e "${GREEN}✓ Dump file size: ${REMOTE_SIZE}${NC}"

# Compress on remote server if enabled
if [ "$COMPRESSION_ENABLED" = true ]; then
    echo ""
    echo -e "${YELLOW}Step 3/5: Compressing dump file on remote server...${NC}"
    echo "Compression type: ${COMPRESSION_TYPE} (level: ${COMPRESSION_LEVEL})"

    ssh -p ${REMOTE_PORT} ${REMOTE_USER}@${REMOTE_HOST} "$COMPRESS_CMD $REMOTE_DUMP_PATH"

    if [ $? -eq 0 ]; then
        # Update paths to include compression extension
        REMOTE_DUMP_PATH="${REMOTE_DUMP_PATH}${COMPRESSION_EXT}"
        LOCAL_DUMP_PATH="${LOCAL_DUMP_PATH}${COMPRESSION_EXT}"

        COMPRESSED_SIZE=$(ssh -p ${REMOTE_PORT} ${REMOTE_USER}@${REMOTE_HOST} "ls -lh $REMOTE_DUMP_PATH | awk '{print \$5}'")
        COMPRESSED_SIZE_BYTES=$(ssh -p ${REMOTE_PORT} ${REMOTE_USER}@${REMOTE_HOST} "stat -f%z $REMOTE_DUMP_PATH 2>/dev/null || stat -c%s $REMOTE_DUMP_PATH 2>/dev/null")

        # Calculate compression ratio
        if [ -n "$REMOTE_SIZE_BYTES" ] && [ -n "$COMPRESSED_SIZE_BYTES" ]; then
            COMPRESSION_RATIO=$(awk "BEGIN {printf \"%.1f\", ($REMOTE_SIZE_BYTES / $COMPRESSED_SIZE_BYTES)}")
            SPACE_SAVED=$(awk "BEGIN {printf \"%.1f\", (($REMOTE_SIZE_BYTES - $COMPRESSED_SIZE_BYTES) / $REMOTE_SIZE_BYTES * 100)}")
            echo -e "${GREEN}✓ Compressed size: ${COMPRESSED_SIZE} (ratio: ${COMPRESSION_RATIO}x, saved: ${SPACE_SAVED}%)${NC}"
        else
            echo -e "${GREEN}✓ Compressed size: ${COMPRESSED_SIZE}${NC}"
        fi
    else
        echo -e "${RED}✗ Failed to compress dump file${NC}"
        exit 1
    fi
else
    echo ""
    echo -e "${YELLOW}Step 3/5: Skipping compression (disabled)${NC}"
fi

echo ""
echo -e "${YELLOW}Step 4/5: Transferring dump file to local server...${NC}"
scp -P ${REMOTE_PORT} ${REMOTE_USER}@${REMOTE_HOST}:${REMOTE_DUMP_PATH} ${LOCAL_DUMP_PATH}

if [ $? -eq 0 ]; then
    echo -e "${GREEN}✓ File transferred successfully${NC}"
    echo "Local path: ${LOCAL_DUMP_PATH}"
else
    echo -e "${RED}✗ Failed to transfer file${NC}"
    exit 1
fi

echo ""
echo -e "${YELLOW}Step 5/5: Cleaning up remote dump file...${NC}"
ssh -p ${REMOTE_PORT} ${REMOTE_USER}@${REMOTE_HOST} "rm -f $REMOTE_DUMP_PATH"

if [ $? -eq 0 ]; then
    echo -e "${GREEN}✓ Remote cleanup completed${NC}"
else
    echo -e "${YELLOW}⚠ Warning: Failed to clean up remote dump file${NC}"
fi

# Decompress locally if compression was used
if [ "$COMPRESSION_ENABLED" = true ]; then
    echo ""
    echo -e "${YELLOW}Decompressing file locally...${NC}"

    $DECOMPRESS_CMD "$LOCAL_DUMP_PATH"

    if [ $? -eq 0 ]; then
        # Remove compression extension from path
        LOCAL_DUMP_PATH="${LOCAL_DUMP_PATH%${COMPRESSION_EXT}}"
        LOCAL_SIZE=$(ls -lh "$LOCAL_DUMP_PATH" | awk '{print $5}')
        echo -e "${GREEN}✓ Decompressed successfully${NC}"
        echo "Decompressed size: ${LOCAL_SIZE}"
    else
        echo -e "${RED}✗ Failed to decompress file${NC}"
        exit 1
    fi
fi

echo ""
echo -e "${GREEN}=== Database Sync Completed Successfully ===${NC}"
FINAL_DUMP_SIZE=$(ls -lh "$LOCAL_DUMP_PATH" | awk '{print $5}')
echo "Dump file: ${LOCAL_DUMP_PATH}"
echo "DUMP_SIZE=${FINAL_DUMP_SIZE}"

# Cleanup old dumps if KEEP_DUMPS is set
if [ "$KEEP_DUMPS" -gt 0 ]; then
    echo ""
    echo -e "${YELLOW}Cleaning up old dumps (keeping last $KEEP_DUMPS)...${NC}"

    # Find all dump files for this database, sorted by modification time (oldest first)
    # Pattern: ${DATABASE}_*.dump
    OLD_DUMPS=$(find "$LOCAL_DUMP_DIR" -name "${DATABASE}_*.dump" -type f -printf '%T+ %p\n' 2>/dev/null | sort | awk '{print $2}')

    # Count total dumps
    TOTAL_DUMPS=$(echo "$OLD_DUMPS" | grep -c "^" 2>/dev/null || echo 0)

    if [ "$TOTAL_DUMPS" -gt "$KEEP_DUMPS" ]; then
        # Calculate how many to delete
        DELETE_COUNT=$((TOTAL_DUMPS - KEEP_DUMPS))

        echo "Found $TOTAL_DUMPS dumps, deleting oldest $DELETE_COUNT..."

        # Delete oldest dumps
        echo "$OLD_DUMPS" | head -n "$DELETE_COUNT" | while read -r dump_file; do
            if [ -f "$dump_file" ]; then
                echo "  Deleting: $(basename "$dump_file")"
                rm -f "$dump_file"
            fi
        done

        echo -e "${GREEN}✓ Cleanup completed${NC}"
    else
        echo -e "${GREEN}✓ No cleanup needed (found $TOTAL_DUMPS dumps, keeping $KEEP_DUMPS)${NC}"
    fi
fi

# Clear this command from bash history (security)
if [ -n "$BASH_VERSION" ]; then
    history -d $(history 1 | awk '{print $1}') 2>/dev/null || true
fi

# Auto restore if requested
if [ "$AUTO_RESTORE" = true ]; then
    echo ""
    echo -e "${GREEN}=== Starting Database Restore ===${NC}"

    # Check if database exists
    echo -e "${YELLOW}Step 1/3: Checking if database exists...${NC}"
    DB_EXISTS=$(PGPASSWORD="$DEST_DB_PASSWORD" psql -U "$DEST_DB_USER" -h "$DEST_DB_HOST" -p "$DEST_DB_PORT" -t -c "SELECT 1 FROM pg_database WHERE datname='$DEST_DB_NAME'" postgres 2>/dev/null | xargs)

    if [ "$DB_EXISTS" = "1" ]; then
        echo -e "${YELLOW}Database '$DEST_DB_NAME' exists. Terminating active connections...${NC}"

        # Terminate all connections to the database
        PGPASSWORD="$DEST_DB_PASSWORD" psql -U "$DEST_DB_USER" -h "$DEST_DB_HOST" -p "$DEST_DB_PORT" -c "SELECT pg_terminate_backend(pid) FROM pg_stat_activity WHERE datname='$DEST_DB_NAME' AND pid <> pg_backend_pid();" postgres > /dev/null 2>&1

        echo -e "${YELLOW}Dropping database '$DEST_DB_NAME'...${NC}"
        PGPASSWORD="$DEST_DB_PASSWORD" dropdb -U "$DEST_DB_USER" -h "$DEST_DB_HOST" -p "$DEST_DB_PORT" "$DEST_DB_NAME" 2>&1

        if [ $? -eq 0 ]; then
            echo -e "${GREEN}✓ Database dropped successfully${NC}"
        else
            echo -e "${RED}✗ Failed to drop database${NC}"
            exit 1
        fi
    else
        echo -e "${GREEN}✓ Database does not exist, will create new one${NC}"
    fi

    echo ""
    echo -e "${YELLOW}Step 2/3: Creating database '$DEST_DB_NAME'...${NC}"
    PGPASSWORD="$DEST_DB_PASSWORD" createdb -U "$DEST_DB_USER" -h "$DEST_DB_HOST" -p "$DEST_DB_PORT" "$DEST_DB_NAME" 2>&1

    if [ $? -eq 0 ]; then
        echo -e "${GREEN}✓ Database created successfully${NC}"
    else
        echo -e "${RED}✗ Failed to create database${NC}"
        exit 1
    fi

    echo ""
    echo -e "${YELLOW}Step 3/3: Restoring backup to database...${NC}"
    echo "This may take a while depending on the database size..."
    echo ""

    PGPASSWORD="$DEST_DB_PASSWORD" pg_restore \
        --verbose \
        --no-owner \
        --no-privileges \
        --clean \
        --if-exists \
        --exit-on-error \
        -U "$DEST_DB_USER" \
        -h "$DEST_DB_HOST" \
        -p "$DEST_DB_PORT" \
        -d "$DEST_DB_NAME" \
        "$LOCAL_DUMP_PATH" 2>&1

    RESTORE_EXIT_CODE=${PIPESTATUS[0]}

    if [ $RESTORE_EXIT_CODE -eq 0 ]; then
        echo ""
        echo -e "${GREEN}✓ Database restored successfully${NC}"
    else
        echo ""
        echo -e "${YELLOW}⚠ Restore completed with some warnings (this is usually normal)${NC}"
    fi

    echo ""
    echo -e "${GREEN}=== Database Restore Completed ===${NC}"
else
    echo ""
    echo "To restore this dump manually, use:"
    echo "  PGPASSWORD='yourpassword' pg_restore --verbose --no-owner --no-privileges --clean --if-exists -U $DEST_DB_USER -h $DEST_DB_HOST -p $DEST_DB_PORT -d $DEST_DB_NAME \"$LOCAL_DUMP_PATH\""
fi
