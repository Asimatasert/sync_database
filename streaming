#!/bin/bash

# streaming - PostgreSQL Streaming Dump/Restore
# Reduces disk usage by piping directly from source to destination

# Streaming settings
STREAMING_ENABLED=false
STREAMING_WITH_COMPRESSION=true
STREAMING_BUFFER_SIZE="64M"  # Buffer size for pv (pipe viewer)
STREAMING_SHOW_PROGRESS=true

# Color codes
STREAM_GREEN='\033[0;32m'
STREAM_YELLOW='\033[1;33m'
STREAM_BLUE='\033[0;34m'
STREAM_RED='\033[0;31m'
STREAM_NC='\033[0m'

# Function to check if pv (pipe viewer) is available
check_pv_available() {
    if command -v pv &> /dev/null; then
        return 0
    else
        return 1
    fi
}

# Function to perform streaming dump and restore (remote to local)
stream_remote_to_local() {
    local database=$1
    local remote_user=$2
    local remote_host=$3
    local remote_port=$4
    local source_host=$5
    local source_port=$6
    local source_user=$7
    local source_password=$8
    local dest_db=$9
    local dest_host=${10}
    local dest_port=${11}
    local dest_user=${12}
    local dest_password=${13}

    echo ""
    echo -e "${STREAM_BLUE}=== PostgreSQL Streaming Sync ===${STREAM_NC}"
    echo "Mode: Streaming (No intermediate files)"
    echo "Source: ${source_host}:${source_port}/${database}"
    echo "Destination: ${dest_host}:${dest_port}/${dest_db}"
    echo ""

    # Build remote pg_dump command
    local remote_dump_cmd="PGPASSWORD='$source_password' pg_dump -U $source_user -h $source_host -p $source_port -Fc $database"

    # Add exclude options if present
    if [ -n "$EXCLUDE_TABLES" ]; then
        IFS=',' read -ra TABLES <<< "$EXCLUDE_TABLES"
        for table in "${TABLES[@]}"; do
            table=$(echo "$table" | xargs)
            remote_dump_cmd="$remote_dump_cmd --exclude-table='$table'"
        done
    fi

    if [ -n "$EXCLUDE_SCHEMAS" ]; then
        IFS=',' read -ra SCHEMAS <<< "$EXCLUDE_SCHEMAS"
        for schema in "${SCHEMAS[@]}"; do
            schema=$(echo "$schema" | xargs)
            remote_dump_cmd="$remote_dump_cmd --exclude-schema='$schema'"
        done
    fi

    # Prepare destination database
    echo -e "${STREAM_YELLOW}Step 1/3: Preparing destination database...${STREAM_NC}"

    # Check if database exists
    local db_exists=$(PGPASSWORD="$dest_password" psql -U "$dest_user" -h "$dest_host" -p "$dest_port" -t -c "SELECT 1 FROM pg_database WHERE datname='$dest_db'" postgres 2>/dev/null | xargs)

    if [ "$db_exists" = "1" ]; then
        echo "Terminating connections and dropping existing database..."
        PGPASSWORD="$dest_password" psql -U "$dest_user" -h "$dest_host" -p "$dest_port" -c "SELECT pg_terminate_backend(pid) FROM pg_stat_activity WHERE datname='$dest_db' AND pid <> pg_backend_pid();" postgres > /dev/null 2>&1
        PGPASSWORD="$dest_password" dropdb -U "$dest_user" -h "$dest_host" -p "$dest_port" "$dest_db" 2>&1
    fi

    echo "Creating new database..."
    PGPASSWORD="$dest_password" createdb -U "$dest_user" -h "$dest_host" -p "$dest_port" "$dest_db" 2>&1

    if [ $? -ne 0 ]; then
        echo -e "${STREAM_RED}✗ Failed to create destination database${STREAM_NC}"
        return 1
    fi

    echo -e "${STREAM_GREEN}✓ Destination database ready${STREAM_NC}"

    # Build streaming pipeline
    echo ""
    echo -e "${STREAM_YELLOW}Step 2/3: Streaming data...${STREAM_NC}"

    local pipeline=""

    if [ "$STREAMING_WITH_COMPRESSION" = "true" ]; then
        echo "Pipeline: Remote Dump → gzip → SSH → gunzip → Local Restore"

        if check_pv_available && [ "$STREAMING_SHOW_PROGRESS" = "true" ]; then
            # With progress monitoring
            pipeline="ssh -p ${remote_port} ${remote_user}@${remote_host} \"$remote_dump_cmd | gzip\" | pv -N 'Streaming' | gunzip | PGPASSWORD='$dest_password' pg_restore --verbose --no-owner --no-privileges -U $dest_user -h $dest_host -p $dest_port -d $dest_db 2>&1"
        else
            # Without progress monitoring
            pipeline="ssh -p ${remote_port} ${remote_user}@${remote_host} \"$remote_dump_cmd | gzip\" | gunzip | PGPASSWORD='$dest_password' pg_restore --verbose --no-owner --no-privileges -U $dest_user -h $dest_host -p $dest_port -d $dest_db 2>&1"
        fi
    else
        echo "Pipeline: Remote Dump → SSH → Local Restore"

        if check_pv_available && [ "$STREAMING_SHOW_PROGRESS" = "true" ]; then
            # With progress monitoring
            pipeline="ssh -p ${remote_port} ${remote_user}@${remote_host} \"$remote_dump_cmd\" | pv -N 'Streaming' | PGPASSWORD='$dest_password' pg_restore --verbose --no-owner --no-privileges -U $dest_user -h $dest_host -p $dest_port -d $dest_db 2>&1"
        else
            # Without progress monitoring
            pipeline="ssh -p ${remote_port} ${remote_user}@${remote_host} \"$remote_dump_cmd\" | PGPASSWORD='$dest_password' pg_restore --verbose --no-owner --no-privileges -U $dest_user -h $dest_host -p $dest_port -d $dest_db 2>&1"
        fi
    fi

    echo ""
    echo "Starting stream..."
    echo ""

    # Record start time
    local start_time=$(date +%s)

    # Execute streaming pipeline
    eval "$pipeline"
    local stream_exit_code=$?

    # Calculate duration
    local end_time=$(date +%s)
    local duration=$((end_time - start_time))
    local hours=$((duration / 3600))
    local minutes=$(((duration % 3600) / 60))
    local seconds=$((duration % 60))
    local duration_formatted=$(printf "%02d:%02d:%02d" $hours $minutes $seconds)

    echo ""
    echo -e "${STREAM_YELLOW}Step 3/3: Verifying...${STREAM_NC}"

    if [ $stream_exit_code -eq 0 ] || [ $stream_exit_code -eq 1 ]; then
        # Exit code 1 is often warnings, which is acceptable
        echo -e "${STREAM_GREEN}✓ Stream completed${STREAM_NC}"
        echo "Duration: $duration_formatted"
        echo ""
        echo -e "${STREAM_GREEN}=== Streaming Sync Completed ===${STREAM_NC}"
        echo "Database: $database → $dest_db"
        echo "Duration: $duration_formatted"
        echo "Disk usage: Zero intermediate files"
        return 0
    else
        echo -e "${STREAM_RED}✗ Stream failed with exit code: $stream_exit_code${STREAM_NC}"
        return 1
    fi
}

# Function to perform streaming clone (localhost to localhost)
stream_local_clone() {
    local database=$1
    local source_host=$2
    local source_port=$3
    local source_user=$4
    local source_password=$5
    local dest_db=$6
    local dest_host=$7
    local dest_port=$8
    local dest_user=$9
    local dest_password=${10}

    echo ""
    echo -e "${STREAM_BLUE}=== PostgreSQL Streaming Clone ===${STREAM_NC}"
    echo "Mode: Streaming Local Clone (No intermediate files)"
    echo "Source: ${source_host}:${source_port}/${database}"
    echo "Destination: ${dest_host}:${dest_port}/${dest_db}"
    echo ""

    # Build pg_dump command
    local dump_cmd="PGPASSWORD='$source_password' pg_dump -U $source_user -h $source_host -p $source_port -Fc $database"

    # Add exclude options if present
    if [ -n "$EXCLUDE_TABLES" ]; then
        IFS=',' read -ra TABLES <<< "$EXCLUDE_TABLES"
        for table in "${TABLES[@]}"; do
            table=$(echo "$table" | xargs)
            dump_cmd="$dump_cmd --exclude-table='$table'"
        done
    fi

    if [ -n "$EXCLUDE_SCHEMAS" ]; then
        IFS=',' read -ra SCHEMAS <<< "$EXCLUDE_SCHEMAS"
        for schema in "${SCHEMAS[@]}"; do
            schema=$(echo "$schema" | xargs)
            dump_cmd="$dump_cmd --exclude-schema='$schema'"
        done
    fi

    # Prepare destination database
    echo -e "${STREAM_YELLOW}Step 1/2: Preparing destination database...${STREAM_NC}"

    local db_exists=$(PGPASSWORD="$dest_password" psql -U "$dest_user" -h "$dest_host" -p "$dest_port" -t -c "SELECT 1 FROM pg_database WHERE datname='$dest_db'" postgres 2>/dev/null | xargs)

    if [ "$db_exists" = "1" ]; then
        echo "Terminating connections and dropping existing database..."
        PGPASSWORD="$dest_password" psql -U "$dest_user" -h "$dest_host" -p "$dest_port" -c "SELECT pg_terminate_backend(pid) FROM pg_stat_activity WHERE datname='$dest_db' AND pid <> pg_backend_pid();" postgres > /dev/null 2>&1
        PGPASSWORD="$dest_password" dropdb -U "$dest_user" -h "$dest_host" -p "$dest_port" "$dest_db" 2>&1
    fi

    echo "Creating new database..."
    PGPASSWORD="$dest_password" createdb -U "$dest_user" -h "$dest_host" -p "$dest_port" "$dest_db" 2>&1

    if [ $? -ne 0 ]; then
        echo -e "${STREAM_RED}✗ Failed to create destination database${STREAM_NC}"
        return 1
    fi

    echo -e "${STREAM_GREEN}✓ Destination database ready${STREAM_NC}"

    # Build streaming pipeline
    echo ""
    echo -e "${STREAM_YELLOW}Step 2/2: Streaming clone...${STREAM_NC}"
    echo "Pipeline: Local Dump → Local Restore"
    echo ""

    # Record start time
    local start_time=$(date +%s)

    # Execute streaming pipeline
    if check_pv_available && [ "$STREAMING_SHOW_PROGRESS" = "true" ]; then
        eval "$dump_cmd | pv -N 'Cloning' | PGPASSWORD='$dest_password' pg_restore --verbose --no-owner --no-privileges -U $dest_user -h $dest_host -p $dest_port -d $dest_db 2>&1"
    else
        eval "$dump_cmd | PGPASSWORD='$dest_password' pg_restore --verbose --no-owner --no-privileges -U $dest_user -h $dest_host -p $dest_port -d $dest_db 2>&1"
    fi

    local stream_exit_code=$?

    # Calculate duration
    local end_time=$(date +%s)
    local duration=$((end_time - start_time))
    local hours=$((duration / 3600))
    local minutes=$(((duration % 3600) / 60))
    local seconds=$((duration % 60))
    local duration_formatted=$(printf "%02d:%02d:%02d" $hours $minutes $seconds)

    echo ""
    if [ $stream_exit_code -eq 0 ] || [ $stream_exit_code -eq 1 ]; then
        echo -e "${STREAM_GREEN}✓ Clone completed${STREAM_NC}"
        echo "Duration: $duration_formatted"
        echo ""
        echo -e "${STREAM_GREEN}=== Streaming Clone Completed ===${STREAM_NC}"
        echo "Cloned: $database → $dest_db"
        echo "Duration: $duration_formatted"
        echo "Disk usage: Zero intermediate files"
        return 0
    else
        echo -e "${STREAM_RED}✗ Clone failed with exit code: $stream_exit_code${STREAM_NC}"
        return 1
    fi
}
