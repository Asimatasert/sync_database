#!/bin/bash

# telegram_bot_service - Telegram Bot Service for Database Sync Control
# This service allows you to control database synchronization via Telegram bot
# Usage: bash telegram_bot_service [config_file]

set -e

# Don't exit on error during systemd check
set +e

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
CYAN='\033[0;36m'
NC='\033[0m' # No Color

# Get the directory where this script is located
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
SCRIPT_NAME="$(basename "${BASH_SOURCE[0]}")"
SCRIPT_PATH="${SCRIPT_DIR}/${SCRIPT_NAME}"

# Default config file
if [ -n "$1" ]; then
    CONFIG_FILE="$1"
else
    CONFIG_FILE="${SCRIPT_DIR}/sync_database.json"
fi

# Service file info
SERVICE_NAME="telegram-bot-sync.service"
SERVICE_FILE="${SCRIPT_DIR}/${SERVICE_NAME}"
SYSTEMD_SERVICE_PATH="/etc/systemd/system/${SERVICE_NAME}"

# Function to check if systemd service exists
check_systemd_service() {
    if systemctl list-unit-files | grep -q "^${SERVICE_NAME}"; then
        return 0
    else
        return 1
    fi
}

# Function to offer systemd service installation
offer_service_installation() {
    echo ""
    echo -e "${YELLOW}╔════════════════════════════════════════════════════════════╗${NC}"
    echo -e "${YELLOW}║  Systemd Service Installation                             ║${NC}"
    echo -e "${YELLOW}╚════════════════════════════════════════════════════════════╝${NC}"
    echo ""
    echo -e "${CYAN}Telegram bot service not installed on system.${NC}"
    echo ""
    echo -e "${GREEN}Installing as systemd service provides:${NC}"
    echo "  ✅ Auto-start on system boot"
    echo "  ✅ Auto-restart on crash"
    echo "  ✅ Easy management with systemctl"
    echo "  ✅ Log management with journalctl"
    echo ""
    echo -e "${YELLOW}Running manually means:${NC}"
    echo "  ⚠️  Bot stops when terminal closes"
    echo "  ⚠️  Manual start required each time"
    echo ""

    read -p "Install as systemd service? (y/n): " response

    case "$response" in
        [eE]|[eE][vV][eE][tT]|[yY]|[yY][eE][sS])
            install_systemd_service
            ;;
        *)
            echo ""
            echo -e "${CYAN}Manual mode selected. Starting bot now...${NC}"
            echo -e "${YELLOW}Note: To install service later: sudo bash $SCRIPT_NAME --install-service${NC}"
            echo ""
            sleep 2
            ;;
    esac
}

# Function to install systemd service
install_systemd_service() {
    echo ""
    echo -e "${CYAN}Installing systemd service...${NC}"

    # Check if service file exists
    if [ ! -f "$SERVICE_FILE" ]; then
        echo -e "${RED}Error: Service file not found: $SERVICE_FILE${NC}"
        echo "Please place telegram-bot-sync.service file in ${SCRIPT_DIR}"
        exit 1
    fi

    # Create a temporary service file with correct paths
    local temp_service="/tmp/${SERVICE_NAME}"
    cat "$SERVICE_FILE" | \
        sed "s|/home/YOUR_USERNAME/telegram_bot_service|$SCRIPT_PATH|g" | \
        sed "s|/home/YOUR_USERNAME/sync_database.json|$CONFIG_FILE|g" | \
        sed "s|WorkingDirectory=.*|WorkingDirectory=$SCRIPT_DIR|g" > "$temp_service"

    # Copy to systemd directory (requires sudo)
    echo -e "${YELLOW}Copying to systemd directory (requires sudo)...${NC}"
    sudo cp "$temp_service" "$SYSTEMD_SERVICE_PATH"

    if [ $? -eq 0 ]; then
        echo -e "${GREEN}✓ Service file copied${NC}"

        # Reload systemd
        sudo systemctl daemon-reload
        echo -e "${GREEN}✓ Systemd reloaded${NC}"

        # Enable service
        sudo systemctl enable "$SERVICE_NAME"
        echo -e "${GREEN}✓ Service enabled for auto-start${NC}"

        # Start service
        sudo systemctl start "$SERVICE_NAME"
        echo -e "${GREEN}✓ Service started${NC}"

        echo ""
        echo -e "${GREEN}╔════════════════════════════════════════════════════════════╗${NC}"
        echo -e "${GREEN}║  Installation Complete! ✅                                 ║${NC}"
        echo -e "${GREEN}╚════════════════════════════════════════════════════════════╝${NC}"
        echo ""
        echo -e "${CYAN}Service management commands:${NC}"
        echo "  Check status:  sudo systemctl status $SERVICE_NAME"
        echo "  View logs:     sudo journalctl -u $SERVICE_NAME -f"
        echo "  Restart:       sudo systemctl restart $SERVICE_NAME"
        echo "  Stop:          sudo systemctl stop $SERVICE_NAME"
        echo ""

        # Ask if user wants to see logs
        read -p "View service logs now? (y/n): " show_logs
        case "$show_logs" in
            [eE]|[eE][vV][eE][tT]|[yY]|[yY][eE][sS])
                echo ""
                echo -e "${CYAN}Viewing logs (Press Ctrl+C to exit)...${NC}"
                sleep 2
                sudo journalctl -u "$SERVICE_NAME" -f
                ;;
            *)
                echo ""
                echo -e "${GREEN}Bot is running in background. Test it on Telegram!${NC}"
                exit 0
                ;;
        esac

        exit 0
    else
        echo -e "${RED}✗ Failed to copy service file${NC}"
        echo "Please check your sudo permissions."
        exit 1
    fi
}

# Check for --install-service flag
if [ "$1" = "--install-service" ]; then
    install_systemd_service
    exit 0
fi

# Check if config file exists
if [ ! -f "$CONFIG_FILE" ]; then
    echo -e "${RED}Error: Config file not found: $CONFIG_FILE${NC}"
    exit 1
fi

# Re-enable exit on error for the rest of the script
set -e

# Check if jq is installed
if ! command -v jq &> /dev/null; then
    echo -e "${RED}Error: jq is not installed${NC}"
    echo "Please install jq: brew install jq (macOS) or sudo apt-get install jq (Linux)"
    exit 1
fi

# Check if curl is installed
if ! command -v curl &> /dev/null; then
    echo -e "${RED}Error: curl is not installed${NC}"
    exit 1
fi

# Load Telegram settings from config
BOT_TOKEN=$(jq -r '.global_options.telegram.bot_token // ""' "$CONFIG_FILE")
CHAT_ID=$(jq -r '.global_options.telegram.chat_id // ""' "$CONFIG_FILE")
TELEGRAM_ENABLED=$(jq -r '.global_options.telegram.enabled // false' "$CONFIG_FILE")
SEND_STARTUP_NOTIFICATION=$(jq -r '.global_options.telegram.send_startup_notification // false' "$CONFIG_FILE")

# Load authorized users from config
AUTHORIZED_USERS=$(jq -r '.global_options.telegram.authorized_users[]? // empty' "$CONFIG_FILE")

if [ "$TELEGRAM_ENABLED" != "true" ]; then
    echo -e "${RED}Error: Telegram is not enabled in config${NC}"
    echo "Please set 'telegram.enabled: true' in $CONFIG_FILE"
    exit 1
fi

if [ -z "$BOT_TOKEN" ] || [ -z "$CHAT_ID" ]; then
    echo -e "${RED}Error: Telegram bot_token or chat_id not configured${NC}"
    exit 1
fi

# API Base URL
API_URL="https://api.telegram.org/bot${BOT_TOKEN}"

# State file to track last update
STATE_FILE="${SCRIPT_DIR}/.telegram_bot_state"

# Sync database runner script
SYNC_RUNNER="${SCRIPT_DIR}/sync_database_runner"

# PID file for sync operations
SYNC_PID_FILE="${SCRIPT_DIR}/.sync_running.pid"

# Log file
LOG_FILE="${SCRIPT_DIR}/data/dumps/telegram_bot.log"
mkdir -p "$(dirname "$LOG_FILE")"

# Function to log messages
log_message() {
    local timestamp=$(date '+%Y-%m-%d %H:%M:%S')
    echo "[$timestamp] $1" >> "$LOG_FILE"
    echo -e "${CYAN}[$timestamp]${NC} $1"
}

# Function to send message to Telegram
send_message() {
    local chat_id="$1"
    local text="$2"
    local parse_mode="${3:-HTML}"

    curl -s -X POST "${API_URL}/sendMessage" \
        -d "chat_id=${chat_id}" \
        -d "text=${text}" \
        -d "parse_mode=${parse_mode}" > /dev/null
}

# Function to check if user is authorized
is_authorized() {
    local user_id="$1"

    # If no authorized users in config, use chat_id as default
    if [ -z "$AUTHORIZED_USERS" ]; then
        # Check if user_id matches chat_id (for group chats, chat_id is negative)
        if [ "$user_id" = "$CHAT_ID" ] || [ "$user_id" = "${CHAT_ID#-}" ]; then
            return 0
        fi
        # Allow any user from the configured chat (for groups)
        return 0
    fi

    # Check if user is in authorized list from config
    echo "$AUTHORIZED_USERS" | grep -q "^${user_id}$"
    return $?
}

# Function to get database list with clickable names
get_database_list() {
    local output=""
    local count=0

    while IFS= read -r db; do
        local name=$(echo "$db" | jq -r '.name')
        local enabled=$(echo "$db" | jq -r '.enabled')

        if [ "$enabled" = "true" ]; then
            local status="✅ Enabled"
        else
            local status="❌ Disabled"
        fi

        # Add clickable code block for each database name
        output+="<code>$name</code> - $status%0A"
        count=$((count + 1))
    done < <(jq -c '.databases[]' "$CONFIG_FILE")

    echo "$output"
}

# Function to check if database exists in config
database_exists() {
    local db_name="$1"
    local exists=$(jq -r --arg name "$db_name" '.databases[] | select(.name == $name) | .name' "$CONFIG_FILE")
    [ -n "$exists" ]
}

# Function to get database config by name
get_database_config() {
    local db_name="$1"
    jq -r --arg name "$db_name" '.databases[] | select(.name == $name)' "$CONFIG_FILE"
}

# Function to check if sync is running
is_sync_running() {
    if [ -f "$SYNC_PID_FILE" ]; then
        local pid=$(cat "$SYNC_PID_FILE")
        if ps -p "$pid" > /dev/null 2>&1; then
            return 0
        else
            # PID file exists but process is not running, clean up
            rm -f "$SYNC_PID_FILE"
            return 1
        fi
    fi
    return 1
}

# Function to start sync operation
start_sync() {
    local chat_id="$1"
    local database_name="$2"

    if is_sync_running; then
        send_message "$chat_id" "⚠️ <b>Sync Already Running</b>%0A%0APlease wait for current operation to complete."
        return 1
    fi

    log_message "Starting sync operation requested by chat_id: $chat_id, database: ${database_name:-all}"

    if [ -n "$database_name" ]; then
        # Check if database exists
        if ! database_exists "$database_name"; then
            send_message "$chat_id" "❌ <b>Database Not Found</b>%0A%0ADatabase '<code>$database_name</code>' not found in config.%0A%0AUse /list to see available databases."
            return 1
        fi

        # Sync specific database - sync_database_runner will send its own notifications
        # Run sync for specific database
        (
            # Get database config
            local db_config=$(get_database_config "$database_name")
            local enabled=$(echo "$db_config" | jq -r '.enabled')

            if [ "$enabled" != "true" ]; then
                send_message "$chat_id" "⚠️ <b>Database Disabled</b>%0A%0ADatabase '<code>$database_name</code>' is disabled in config.%0A%0APlease enable it first."
                rm -f "$SYNC_PID_FILE"
                return 1
            fi

            # Create temporary single-database config
            local temp_config="/tmp/sync_single_db_$$.json"
            jq --arg name "$database_name" '{databases: [.databases[] | select(.name == $name)], global_options: .global_options}' "$CONFIG_FILE" > "$temp_config"

            # Run sync with temporary config - it will send its own Telegram notifications
            bash "$SYNC_RUNNER" "$temp_config" > /tmp/sync_output_$$.log 2>&1
            local exit_code=$?

            rm -f "$temp_config"
            rm -f /tmp/sync_output_$$.log
            rm -f "$SYNC_PID_FILE"

            # Only send message if sync failed (sync_database_runner already sends success messages)
            if [ $exit_code -ne 0 ]; then
                send_message "$chat_id" "❌ <b>Sync Failed</b>%0A%0ADatabase: <code>$database_name</code>%0A%0ACheck logs for details.%0AUse /logs to see recent errors."
                log_message "Sync failed for database: $database_name with exit code: $exit_code"
            fi
        ) &
    else
        # Sync all enabled databases - sync_database_runner will send its own notifications
        # Run sync in background and capture PID
        (
            bash "$SYNC_RUNNER" "$CONFIG_FILE" > /tmp/sync_output_$$.log 2>&1
            local exit_code=$?

            rm -f /tmp/sync_output_$$.log
            rm -f "$SYNC_PID_FILE"

            # Only send message if sync failed (sync_database_runner already sends success messages)
            if [ $exit_code -ne 0 ]; then
                send_message "$chat_id" "❌ <b>Full Sync Failed</b>%0A%0ACheck logs for details.%0AUse /logs to see recent errors."
                log_message "Full sync failed with exit code: $exit_code"
            fi
        ) &
    fi

    echo $! > "$SYNC_PID_FILE"
}

# Function to get sync status
get_sync_status() {
    if is_sync_running; then
        local pid=$(cat "$SYNC_PID_FILE")
        echo "🔄 <b>Sync In Progress</b>%0A%0APID: <code>$pid</code>%0AStatus: Running"
    else
        local last_run=$(tail -1 "$LOG_FILE" 2>/dev/null || echo "No previous runs")
        echo "✅ <b>No Active Sync</b>%0A%0AReady to start new operation.%0A%0ALast activity:%0A<pre>$last_run</pre>"
    fi
}

# Function to get recent logs
get_recent_logs() {
    local lines="${1:-20}"
    local logs=$(tail -n "$lines" "$LOG_FILE" 2>/dev/null || echo "No logs available")
    echo "<b>Recent Logs (last $lines lines):</b>%0A%0A<pre>$logs</pre>"
}

# Function to process commands
process_command() {
    local chat_id="$1"
    local user_id="$2"
    local username="$3"
    local command="$4"
    local args="$5"

    log_message "Command received from user $username ($user_id): $command $args"

    # Check authorization
    if ! is_authorized "$user_id"; then
        send_message "$chat_id" "🚫 <b>Unauthorized Access</b>%0A%0AYou are not authorized to use this bot.%0AYour User ID: <code>$user_id</code>"
        log_message "Unauthorized access attempt from user_id: $user_id ($username)"
        return
    fi

    case "$command" in
        /start)
            local welcome="👋 <b>Welcome to Database Sync Bot!</b>%0A%0A"
            welcome+="I can help you manage database synchronization operations.%0A%0A"
            welcome+="<b>Available Commands:</b>%0A"
            welcome+="/sync - Sync all enabled databases%0A"
            welcome+="/sync [name] - Sync specific database%0A"
            welcome+="/status - Check sync status%0A"
            welcome+="/list - List all databases%0A"
            welcome+="/logs [N] - Show last N log lines%0A"
            welcome+="/stop - Stop running sync%0A"
            welcome+="/help - Show help and examples"
            send_message "$chat_id" "$welcome"
            ;;

        /help)
            local help="📚 <b>Database Sync Bot - Help</b>%0A%0A"
            help+="<b>Commands:</b>%0A"
            help+="/sync - Sync all enabled databases%0A"
            help+="/sync [name] - Sync specific database%0A"
            help+="/status - Show current sync status%0A"
            help+="/list - List all databases%0A"
            help+="/logs [N] - Show last N lines (default: 20)%0A"
            help+="/stop - Stop running sync%0A"
            help+="/help - Show this help%0A%0A"
            help+="<b>Examples:</b>%0A"
            help+="<code>/sync</code> - Sync all databases%0A"
            help+="<code>/sync Production DB</code> - Sync specific%0A"
            help+="<code>/logs 50</code> - Show 50 lines%0A%0A"
            help+="<b>Your Info:</b>%0A"
            help+="User ID: <code>$user_id</code>%0A"
            help+="Username: $username%0A%0A"
            help+="<b>Authorization:</b>%0A"
            if [ -n "$AUTHORIZED_USERS" ]; then
                help+="✅ Specific users only%0A"
            else
                help+="✅ All chat members%0A"
            fi
            help+="Config: <code>$CONFIG_FILE</code>"
            send_message "$chat_id" "$help"
            ;;

        /sync)
            # Check if database name is provided as argument
            if [ -n "$args" ]; then
                start_sync "$chat_id" "$args"
            else
                start_sync "$chat_id" ""
            fi
            ;;

        /status)
            local status=$(get_sync_status)
            send_message "$chat_id" "$status"
            ;;

        /list)
            local db_list=$(get_database_list)
            local message="📊 <b>Configured Databases:</b>%0A%0A$db_list%0A💡 <b>Tip:</b> Tap on database name to copy, then use:%0A<code>/sync [database-name]</code>"
            send_message "$chat_id" "$message"
            ;;

        /logs)
            local num_lines="${args:-20}"
            local logs=$(get_recent_logs "$num_lines")
            send_message "$chat_id" "$logs"
            ;;

        /stop)
            if is_sync_running; then
                local pid=$(cat "$SYNC_PID_FILE")
                log_message "Stopping sync process: $pid"

                # Kill the process and all its children
                if kill -0 "$pid" 2>/dev/null; then
                    # Kill process group (parent and all children)
                    pkill -P "$pid" 2>/dev/null || true
                    kill -TERM "$pid" 2>/dev/null || true
                    sleep 2

                    # Force kill if still running
                    if kill -0 "$pid" 2>/dev/null; then
                        kill -KILL "$pid" 2>/dev/null || true
                    fi

                    rm -f "$SYNC_PID_FILE"
                    send_message "$chat_id" "🛑 <b>Sync Stopped</b>%0A%0AOperation has been terminated."
                    log_message "Sync stopped successfully by user request"
                else
                    rm -f "$SYNC_PID_FILE"
                    send_message "$chat_id" "ℹ️ <b>Sync Already Stopped</b>%0A%0AProcess was not running."
                    log_message "Sync process already stopped"
                fi
            else
                send_message "$chat_id" "ℹ️ <b>No Active Sync</b>%0A%0AThere is no running sync operation to stop."
            fi
            ;;

        *)
            send_message "$chat_id" "❓ <b>Unknown Command</b>%0A%0AUse /help to see available commands."
            ;;
    esac
}

# Function to get updates from Telegram
get_updates() {
    local offset="${1:-0}"
    curl -s "${API_URL}/getUpdates?offset=${offset}&timeout=30"
}

# Main bot loop
main() {
    # Check if systemd service exists, if not offer installation
    if ! check_systemd_service; then
        offer_service_installation
    fi

    echo -e "${BLUE}╔════════════════════════════════════════╗${NC}"
    echo -e "${BLUE}║   Telegram Bot Service Started        ║${NC}"
    echo -e "${BLUE}╚════════════════════════════════════════╝${NC}"
    echo ""
    echo "Config file: $CONFIG_FILE"
    echo "Bot Token: ${BOT_TOKEN:0:10}...${BOT_TOKEN: -5}"
    echo "Default Chat ID: $CHAT_ID"

    # Show authorized users
    if [ -n "$AUTHORIZED_USERS" ]; then
        echo "Authorized Users:"
        echo "$AUTHORIZED_USERS" | while read -r uid; do
            echo "  - $uid"
        done
    else
        echo "Authorized Users: All users in configured chat (default mode)"
    fi

    echo "Log file: $LOG_FILE"
    echo ""
    echo -e "${GREEN}Bot is running... Press Ctrl+C to stop${NC}"
    echo ""

    log_message "Telegram Bot Service Started - Authorized users: $(echo "$AUTHORIZED_USERS" | wc -l | xargs) configured"

    # Get last update offset from state file
    local offset=0
    if [ -f "$STATE_FILE" ]; then
        offset=$(cat "$STATE_FILE")
        log_message "Bot restarted - continuing from last update offset: $offset"
    else
        # First time ever - create state file with offset 0
        echo "0" > "$STATE_FILE"
        log_message "First start - initializing bot service"

        # Send startup notification only if enabled in config
        if [ "$SEND_STARTUP_NOTIFICATION" = "true" ]; then
            send_message "$CHAT_ID" "🤖 <b>Bot Started</b>%0A%0ADatabase Sync Bot is now online and ready to receive commands.%0A%0AUse /help to see available commands."
        fi
    fi

    # Main polling loop
    while true; do
        local updates=$(get_updates "$offset")

        # Check if we got valid JSON
        if ! echo "$updates" | jq empty 2>/dev/null; then
            log_message "Error: Invalid JSON response from Telegram API"
            sleep 5
            continue
        fi

        # Process each update
        local result_count=$(echo "$updates" | jq -r '.result | length')

        if [ "$result_count" -gt 0 ]; then
            for i in $(seq 0 $((result_count - 1))); do
                local update=$(echo "$updates" | jq -c ".result[$i]")
                local update_id=$(echo "$update" | jq -r '.update_id')
                local chat_id=$(echo "$update" | jq -r '.message.chat.id // .message.from.id')
                local user_id=$(echo "$update" | jq -r '.message.from.id')
                local username=$(echo "$update" | jq -r '.message.from.username // .message.from.first_name')
                local text=$(echo "$update" | jq -r '.message.text // ""')

                if [ -n "$text" ] && [ "$text" != "null" ]; then
                    # Extract command and arguments
                    local command=$(echo "$text" | awk '{print $1}')
                    local args=$(echo "$text" | cut -d' ' -f2- -s)

                    # Log the command for debugging
                    log_message "Processing command: $command from user $username ($user_id)"

                    # Process the command
                    process_command "$chat_id" "$user_id" "$username" "$command" "$args"
                fi

                # Update offset immediately after processing each update
                offset=$((update_id + 1))
                echo "$offset" > "$STATE_FILE"
            done
        fi

        # Small delay to prevent API flooding
        sleep 1
    done
}

# Trap Ctrl+C and graceful shutdown
# Only send notification on manual stop (INT), not on systemd restart (TERM)
trap 'echo -e "\n${YELLOW}Shutting down bot service...${NC}"; log_message "Bot service stopped (manual)"; exit 0' INT
trap 'log_message "Bot service stopped (systemd restart)"; exit 0' TERM

# Run main loop
main
